import idaapi
import idc
import idautils
import sys

def pseudoCodeObjToString(pseudoCodeOBJ: ida_pro.strvec_t) -> str:
	convertedObj: str = ""

	for lineOBJ in pseudoCodeOBJ:
		convertedObj += (ida_lines.tag_remove(lineOBJ.line) + "\n")

	return convertedObj

def is_special_function(func_ea):
    """
    Checks if a function belongs to special sections or is a known stub,
    using only segment and function names. This is the most compatible approach.

    :param func_ea: The address of the function.
    :return: True if the function is special, False otherwise.
    """
    # 1. Get the segment name for the function's address
    seg = idaapi.getseg(func_ea)
    if not seg:
        return True # Invalid address, skip it.
    
    seg_name = idaapi.get_segm_name(seg)

    # 2. Check for .init, .fini, PLT, and GOT sections
    if seg_name in [".init", ".fini", "extern"] or "plt" in seg_name.lower() or "got" in seg_name.lower():
        return True

    # 3. Check for common prefixes for PLT/GOT stubs
    func_name = idc.get_func_name(func_ea)
    if func_name:
        # Common prefixes for PLT/GOT stubs and library functions
        if func_name.startswith("j_") or func_name.startswith("__plt_") or func_name.startswith("___got_") or func_name.startswith("imp_") or func_name.startswith("sub_"):
            return True
        # Many library functions have a known prefix or pattern
        if func_name in ["start", "init", "fini"]: 
            return True
        
        # Heuristic check: If the function name ends with 'W' or 'A' (e.g., LoadLibraryA),
        # or contains a '@' symbol (e.g., Windows API names), it's likely a library function.
        if func_name.endswith("W") or func_name.endswith("A") or "@" in func_name:
            return True

    return False

def decompile_filtered_functions(output_path):
    """
    Decompiles and saves functions that are not from special sections.

    :param output_path: The path to the output C file.
    """
    print(f"Starting decompilation of filtered functions...")
    
    with open(output_path, "w", encoding='utf-8') as f:
        f.write("// Decompiled functions from IDA Pro (filtered)\n")
        f.write("// Generated by an IDA Python script\n\n")

        total_funcs = 0
        skipped_funcs = 0
        
        for func_ea in idautils.Functions():
            func_name = idc.get_func_name(func_ea)
            #if func_name.startwith("sub_"):
            #    continue
            if not func_name:
                func_name = f"unknown_func_{hex(func_ea)}"

            total_funcs += 1
            
            if is_special_function(func_ea):
                print(f"  Skipping special function: {func_name} at 0x{func_ea:X}")
                skipped_funcs += 1
                continue
            
            print(f"Decompiling function: {func_name} at address 0x{func_ea:X}...")
            
            try:
                cfunc = idaapi.decompile(func_ea)
                if cfunc:
                    # Get pseudocode as a list of simpleline_t objects
                    pseudocode_lines = cfunc.get_pseudocode()
                    
                    # Convert simpleline_t objects to strings
                    pseudocode_text = "".join(pseudoCodeObjToString(pseudocode_lines))

                    # f.write(f"// Function: {func_name}\n")
                    # f.write(f"// Address: 0x{func_ea:X}\n")
                    f.write(pseudocode_text + "\n\n")
                else:
                    print(f"  Failed to decompile {func_name}.")
                    f.write(f"// Failed to decompile function: {func_name} at 0x{func_ea:X}\n\n")
            except Exception as e:
                print(f"  An error occurred while de-compiling {func_name}: {e}")
                f.write(f"// An error occurred while de-compiling function: {func_name} at 0x{func_ea:X}\n\n")


    print(f"Decompilation complete! Output saved to {output_path}")
    print(f"Total functions found: {total_funcs}")
    print(f"Skipped special functions: {skipped_funcs}")
    print(f"Decompiled functions: {total_funcs - skipped_funcs}")

if __name__ == "__main__":
    # Specify your desired output file path here.
    # Make sure you have write permissions for this path.
    output_file = r"D:\workspace\test.c"
    
    if idaapi.init_hexrays_plugin():
        decompile_filtered_functions(output_file)
        idaapi.term_hexrays_plugin()
    else:
        print("Hex-Rays Decompiler is not loaded or available.")